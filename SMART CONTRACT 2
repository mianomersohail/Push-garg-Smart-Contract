// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;
contract Dealing {
    // State variables
    mapping(address => uint256) internal Balance;
    mapping(uint256 => Deals) internal NewDeals;
    uint256 public nextDealId; // Counter for unique Deal IDs
    //ALL MAPPING
    mapping(address=>uint256)public LockAmount;
    //ALL MODIFIERS
    modifier OnlyUser1(uint _Id){
        require(msg.sender==NewDeals[_Id].User1);
        _;
    }
    modifier OnlyUser2(uint _Id){
        require(msg.sender==NewDeals[_Id].User2);
        _;
    }
    modifier Balancecheck(uint _Id){
        require(Balance[msg.sender]>=NewDeals[_Id].Amount);
        _;
    }
    modifier OnlyPending(uint _Id){
        require(NewDeals[_Id].dealStatus==Status.Pending,"The Status Should be Pending");
        _;
    }
    modifier UserNotSame(address _User1,address _User2){
        require(_User1!=_User2,"User1 and User2 Cannot be of Same Address");
        _;
    }
    modifier  DealClos(uint _Id){
        require(NewDeals[_Id].dealStatus==Status.DealAdd,"Deal is not Add yet or Alredy Closed");
        _;
    }
    //ENUM FOR STATUS TRACK
    enum Status { Pending, DealAdd ,DealClose}
    //STRUCT FOR ADDING NEW DEAL
    struct Deals {
        uint256 Id;
        uint256 Amount;
        address User1;
        address User2;
         bool User1Agree;
         bool User2Agree;
         bool User1Done;
         bool User2Done;
        Status dealStatus;
    }
    //ALL FUNCTIONS
    function Withdraw(uint Amount)public payable{
        require(Balance[msg.sender]>=Amount,"Your Balance is Not Enough for Withdraw");
        uint BalanceBefore=Balance[msg.sender];
        Balance[msg.sender]-=Amount;
        payable(msg.sender).transfer(Amount);
        assert(BalanceBefore>Balance[msg.sender]);
    }
    function Deposit(uint Amount)public{
        assert(Amount>0);
        Balance[msg.sender]+=Amount;
    }
    receive() external payable { 
        assert(msg.value>0);
        Balance[msg.sender]+=msg.value;
    }
    function NewDeal(uint256 _Amount, address _User1, address _User2) public UserNotSame(_User1,_User2) {
        uint256 dealId = nextDealId++;
        NewDeals[dealId] = Deals({
            Id: dealId,
            Amount: _Amount,
            User1: _User1,
            User2: _User2,
            User1Agree:false,
            User2Agree:false,
            User1Done:false,
            User2Done:false,
            dealStatus: Status.Pending // Use Status.Pending here
        });
        nextDealId++;
    }
    function User1Agree(uint _Id)public Balancecheck(_Id) OnlyUser1(_Id) OnlyPending(_Id){
        NewDeals[_Id].User1Agree=true;
        if(NewDeals[_Id].User1Agree==true && NewDeals[_Id].User2Agree==true){
        NewDeals[_Id].dealStatus=Status.DealAdd;
        Balance[NewDeals[_Id].User1]-=NewDeals[_Id].Amount;
        Balance[NewDeals[_Id].User2]-=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User1]+=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User2]+=NewDeals[_Id].Amount;
        }
    }
     function User2Agree(uint _Id)public Balancecheck(_Id) OnlyUser2(_Id) OnlyPending(_Id){
        NewDeals[_Id].User2Agree=true;
        if(NewDeals[_Id].User1Agree==true && NewDeals[_Id].User2Agree==true){
        NewDeals[_Id].dealStatus=Status.DealAdd;            
        }
    }
    function User1Satisfy(uint _Id)public DealClos(_Id) OnlyUser1(_Id){
       require(NewDeals[_Id].User1Done!=true,"You already Done to Close Deal");
       NewDeals[_Id].User1Done=true;
       if(NewDeals[_Id].User1Done==true&& NewDeals[_Id].User2Done==true){
                NewDeals[_Id].dealStatus=Status.DealClose;
         Balance[NewDeals[_Id].User1]+=NewDeals[_Id].Amount;
        Balance[NewDeals[_Id].User2]+=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User1]-=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User2]-=NewDeals[_Id].Amount;
        }
    }
    function User2Satisfy(uint _Id)public DealClos(_Id) OnlyUser2(_Id){
       require(NewDeals[_Id].User2Done!=true,"You already Done to Close Deal");
       NewDeals[_Id].User2Done=true;
       if(NewDeals[_Id].User1Done==true&& NewDeals[_Id].User2Done==true){
                NewDeals[_Id].dealStatus=Status.DealClose;
         Balance[NewDeals[_Id].User1]+=NewDeals[_Id].Amount;
        Balance[NewDeals[_Id].User2]+=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User1]-=NewDeals[_Id].Amount;
        LockAmount[NewDeals[_Id].User2]-=NewDeals[_Id].Amount;
        }
        }
        }
