// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
contract Deal{
    mapping(address=>uint256)public Balance;
    mapping(address=>uint256)public LockedAmount;
    address[]public UsesAddresses;
    receive() external payable {
        require(msg.value>0,"Deposit Should be Biger then zero");
        Balance[msg.sender]+=msg.value;
     }

     //CHECK ADDRESS ARE THEY ALREDY IN USE OR NOT
     modifier CheckAddress(address _user){
        bool ispart=false;
        for(uint i=0;i<UsesAddresses.length;i++){
            if(msg.sender==UsesAddresses[i] || _user ==UsesAddresses[i]){
                ispart=true;
                break;
            }

        }
        require(ispart==false,"Buyer or Seller Address is alredy in Use Plz Complete your Previous Deal to Add New One");
        _;
     }
     enum Status {DealAdd,SellerAgree,SellerAgreeDeal,BuyerAgreeeDeal,DealDone}
     struct NewDeal{
        uint Id;
        uint LockAmount;
        address Seller;
        address Buyer;
        Status status;
     }

     NewDeal[]public NewDeals;
     function WithDraw(uint _amount)public{
        require(Balance[msg.sender]>=_amount);
        Balance[msg.sender]-=_amount;
       (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");

     }
     
     function AddNewDeal(address _Seller,uint _LockAmount)public CheckAddress(_Seller){
        require(_LockAmount>0,"Locked Amount Should Not Be Zero");
        require(Balance[msg.sender]>=_LockAmount && Balance[_Seller]>=_LockAmount,"Both Parties Balance Should be minimum Equal to the LockAmount");
        NewDeals.push(NewDeal(NewDeals.length,_LockAmount,_Seller,msg.sender,Status.DealAdd));
            
     }
     function SellerAgree(uint _Id)public {
        require(NewDeals[_Id].status==Status.DealAdd,"Deal is not Add or Alredy Close");
        require(msg.sender==NewDeals[_Id].Seller,"Only Seller of this Deal Can Agree");
        require(Balance[msg.sender]==NewDeals[_Id].LockAmount && Balance[NewDeals[_Id].Buyer]==NewDeals[_Id].LockAmount,"Both Parties Balance Shoudl be eqaul to Minimum of LockAmount");
        Balance[msg.sender]-=NewDeals[_Id].LockAmount;
        Balance[NewDeals[_Id].Buyer]-=NewDeals[_Id].LockAmount;
        UsesAddresses.push(msg.sender);
        UsesAddresses.push(NewDeals[_Id].Buyer);
        NewDeals[_Id].status=Status.SellerAgree;
        LockedAmount[msg.sender]=NewDeals[_Id].LockAmount;
        LockedAmount[NewDeals[_Id].Buyer]=NewDeals[_Id].LockAmount;
     }
     function SellerAgreeDeal(uint _Id)public{
        require(msg.sender==NewDeals[_Id].Seller,"Only Seller of the Deal can Agree");
        require(NewDeals[_Id].status==Status.SellerAgree,"First you will agree for continue Then Agree to Finish Deal or Deal is Alredy Closed");
        NewDeals[_Id].status=Status.SellerAgreeDeal;

     }
     function BuyerAgree(uint _Id)public{
        require(NewDeals[_Id].status==Status.SellerAgreeDeal,"Seller is Not Agreed Yet or Deal is Alredy CLosed");
        require(msg.sender==NewDeals[_Id].Buyer,"Only Buyer of This Deal Can Agree");
        NewDeals[_Id].status=Status.BuyerAgreeeDeal;
        NewDeals[_Id].status=Status.DealDone;
        Balance[NewDeals[_Id].Buyer]+=LockedAmount[NewDeals[_Id].Buyer];
        LockedAmount[NewDeals[_Id].Buyer]=0;
        Balance[NewDeals[_Id].Seller]+=LockedAmount[NewDeals[_Id].Seller];
        LockedAmount[NewDeals[_Id].Seller]=0;
        NewDeals[_Id].status=Status.DealDone;
     }
}
